import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';

const execAsync = promisify(exec);

export interface PluginBuildConfig {
  pluginName: string;
  version: string;
  minecraftVersion: string;
  apiType: 'spigot' | 'paper' | 'bukkit';
  mainClass: string;
  javaCode: string;
  dependencies?: string[];
}

export type ProgressCallback = (progress: number, stage: string, eta: number) => void;

export class MavenBuilder {
  private buildDir = path.join(process.cwd(), 'builds');
  
  constructor() {
    // Ensure builds directory exists
    this.ensureBuildDir();
  }
  
  /**
   * Ensures the builds directory exists
   */
  private async ensureBuildDir(): Promise<void> {
    try {
      await fs.mkdir(this.buildDir, { recursive: true });
    } catch (error) {
      console.error('Failed to create builds directory:', error);
    }
  }
  
  /**
   * Builds a complete Minecraft plugin with Maven
   */
  async buildPlugin(config: PluginBuildConfig, onProgress?: ProgressCallback): Promise<{ jarPath: string; jarBuffer: Buffer }> {
    const projectDir = path.join(this.buildDir, `${config.pluginName}_${Date.now()}`);
    const startTime = Date.now();
    
    try {
      // Create project structure (10%)
      onProgress?.(10, 'Creating project structure', 45);
      await this.createProjectStructure(projectDir, config);
      
      // Generate pom.xml (20%)
      onProgress?.(20, 'Generating Maven configuration', 40);
      await this.generatePomXml(projectDir, config);
      
      // Generate plugin.yml (30%)
      onProgress?.(30, 'Generating plugin metadata', 35);
      await this.generatePluginYml(projectDir, config);
      
      // Write Java source code (40%)
      onProgress?.(40, 'Writing source code', 30);
      await this.writeJavaCode(projectDir, config);
      
      // Build with Maven (40% -> 90%)
      onProgress?.(45, 'Compiling with Maven', 25);
      const jarPath = await this.compileMaven(projectDir, config.pluginName, (mavenProgress) => {
        // Maven takes 50% of total progress (40% to 90%)
        const totalProgress = 40 + (mavenProgress * 0.5);
        const elapsed = (Date.now() - startTime) / 1000;
        const estimatedTotal = elapsed / (totalProgress / 100);
        const eta = Math.max(0, Math.round(estimatedTotal - elapsed));
        onProgress?.(Math.round(totalProgress), 'Compiling with Maven', eta);
      });
      
      // Read JAR file (95%)
      onProgress?.(95, 'Packaging JAR file', 2);
      const jarBuffer = await fs.readFile(jarPath);
      
      // Cleanup (100%)
      onProgress?.(100, 'Build complete', 0);
      await this.cleanup(projectDir);
      
      return { jarPath, jarBuffer };
    } catch (error) {
      // Cleanup on error
      await this.cleanup(projectDir);
      throw error;
    }
  }
  
  /**
   * Creates the Maven project structure
   */
  private async createProjectStructure(projectDir: string, config: PluginBuildConfig): Promise<void> {
    const packagePath = config.mainClass.split('.').slice(0, -1).join('/');
    const srcDir = path.join(projectDir, 'src', 'main', 'java', packagePath);
    const resourcesDir = path.join(projectDir, 'src', 'main', 'resources');
    
    await fs.mkdir(srcDir, { recursive: true });
    await fs.mkdir(resourcesDir, { recursive: true });
  }
  
  /**
   * Generates pom.xml for Maven build
   */
  private async generatePomXml(projectDir: string, config: PluginBuildConfig): Promise<void> {
    const apiVersion = this.getApiVersion(config.minecraftVersion);
    const repository = this.getRepository(config.apiType);
    const dependency = this.getDependency(config.apiType, apiVersion);
    
    const pomXml = `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.coderslab</groupId>
    <artifactId>${config.pluginName.toLowerCase()}</artifactId>
    <version>${config.version}</version>
    <packaging>jar</packaging>

    <name>${config.pluginName}</name>
    <description>Generated by CodersLab</description>

    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>\${java.version}</source>
                    <target>\${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        ${repository}
    </repositories>

    <dependencies>
        ${dependency}
    </dependencies>
</project>`;
    
    await fs.writeFile(path.join(projectDir, 'pom.xml'), pomXml);
  }
  
  /**
   * Generates plugin.yml
   */
  private async generatePluginYml(projectDir: string, config: PluginBuildConfig): Promise<void> {
    const apiVersion = this.getApiVersion(config.minecraftVersion);
    
    const pluginYml = `name: ${config.pluginName}
version: ${config.version}
main: ${config.mainClass}
api-version: '${apiVersion}'
description: Built by Seazon - Join our Discord at https://discord.gg/rx3H3m39AX
author: Seazon
website: https://discord.gg/rx3H3m39AX
`;
    
    const resourcesDir = path.join(projectDir, 'src', 'main', 'resources');
    await fs.writeFile(path.join(resourcesDir, 'plugin.yml'), pluginYml);
    
    // Also create an empty config.yml for plugins that might need it
    const configYml = `# Configuration file for ${config.pluginName}
# Built by Seazon - Join our Discord: https://discord.gg/rx3H3m39AX
# Add your plugin configuration here
`;
    await fs.writeFile(path.join(resourcesDir, 'config.yml'), configYml);
  }
  
  /**
   * Writes Java source code with validation and fixes
   */
  private async writeJavaCode(projectDir: string, config: PluginBuildConfig): Promise<void> {
    const packagePath = config.mainClass.split('.').slice(0, -1).join('/');
    const className = config.mainClass.split('.').pop();
    const packageName = config.mainClass.split('.').slice(0, -1).join('.');
    const srcDir = path.join(projectDir, 'src', 'main', 'java', packagePath);
    
    // Clean and validate code
    let javaCode = this.cleanJavaCode(config.javaCode.trim(), packageName, className!);
    
    await fs.writeFile(path.join(srcDir, `${className}.java`), javaCode);
  }
  
  /**
   * Cleans and validates Java code
   */
  private cleanJavaCode(code: string, packageName: string, className: string): string {
    let cleaned = code.trim();
    
    // Remove any markdown code blocks
    cleaned = cleaned.replace(/```java\n?/g, '').replace(/```\n?/g, '');
    
    // Remove any text after the last closing brace (common AI mistake)
    const lastBrace = cleaned.lastIndexOf('}');
    if (lastBrace !== -1) {
      // Check if there's significant content after the last brace
      const afterBrace = cleaned.substring(lastBrace + 1).trim();
      if (afterBrace.length > 0 && !afterBrace.startsWith('//')) {
        // Remove everything after the last brace
        cleaned = cleaned.substring(0, lastBrace + 1);
      }
    }
    
    // Ensure package declaration exists and is first
    if (!cleaned.includes('package ')) {
      cleaned = `package ${packageName};\n\n${cleaned}`;
    } else {
      // Move package to the top if it's not already there
      const packageMatch = cleaned.match(/package\s+[\w.]+;/);
      if (packageMatch) {
        cleaned = cleaned.replace(packageMatch[0], '');
        cleaned = `${packageMatch[0]}\n\n${cleaned.trim()}`;
      }
    }
    
    // Ensure JavaPlugin import if it's a plugin
    if (cleaned.includes('extends JavaPlugin') && !cleaned.includes('import org.bukkit.plugin.java.JavaPlugin')) {
      const packageEnd = cleaned.indexOf('\n', cleaned.indexOf('package '));
      cleaned = cleaned.slice(0, packageEnd + 1) + '\nimport org.bukkit.plugin.java.JavaPlugin;\n' + cleaned.slice(packageEnd + 1);
    }
    
    // Add common imports if they're used but not imported
    const importsToAdd: string[] = [];
    
    if ((cleaned.includes('Command') || cleaned.includes('onCommand')) && !cleaned.includes('import org.bukkit.command.Command')) {
      importsToAdd.push('import org.bukkit.command.Command;');
    }
    if (cleaned.includes('CommandSender') && !cleaned.includes('import org.bukkit.command.CommandSender')) {
      importsToAdd.push('import org.bukkit.command.CommandSender;');
    }
    if (cleaned.includes('Player') && !cleaned.includes('import org.bukkit.entity.Player')) {
      importsToAdd.push('import org.bukkit.entity.Player;');
    }
    if (cleaned.includes('implements Listener') && !cleaned.includes('import org.bukkit.event.Listener')) {
      importsToAdd.push('import org.bukkit.event.Listener;');
    }
    if (cleaned.includes('@EventHandler') && !cleaned.includes('import org.bukkit.event.EventHandler')) {
      importsToAdd.push('import org.bukkit.event.EventHandler;');
    }
    if (cleaned.includes('Location') && !cleaned.includes('import org.bukkit.Location')) {
      importsToAdd.push('import org.bukkit.Location;');
    }
    if (cleaned.includes('World') && !cleaned.includes('import org.bukkit.World')) {
      importsToAdd.push('import org.bukkit.World;');
    }
    if (cleaned.includes('ItemStack') && !cleaned.includes('import org.bukkit.inventory.ItemStack')) {
      importsToAdd.push('import org.bukkit.inventory.ItemStack;');
    }
    if (cleaned.includes('Material') && !cleaned.includes('import org.bukkit.Material')) {
      importsToAdd.push('import org.bukkit.Material;');
    }
    
    // Fix common event import mistakes - PlayerDeathEvent is in entity package, not player
    if (cleaned.includes('PlayerDeathEvent')) {
      // Remove wrong import if exists
      cleaned = cleaned.replace(/import org\.bukkit\.event\.player\.PlayerDeathEvent;?\n?/g, '');
      // Add correct import if not present
      if (!cleaned.includes('import org.bukkit.event.entity.PlayerDeathEvent')) {
        importsToAdd.push('import org.bukkit.event.entity.PlayerDeathEvent;');
      }
    }
    
    // Add imports after package declaration
    if (importsToAdd.length > 0) {
      const packageEnd = cleaned.indexOf('\n', cleaned.indexOf('package '));
      cleaned = cleaned.slice(0, packageEnd + 1) + '\n' + importsToAdd.join('\n') + '\n' + cleaned.slice(packageEnd + 1);
    }
    
    // Fix common method name mistakes
    // reload() should be reloadConfig()
    cleaned = cleaned.replace(/\breload\(\)/g, 'reloadConfig()');
    // save() should be saveConfig()
    cleaned = cleaned.replace(/\bsave\(\)/g, 'saveConfig()');
    // load() should be loadConfig() (if used)
    cleaned = cleaned.replace(/\bload\(\)/g, 'loadConfig()');
    
    // Ensure the class name matches
    if (!cleaned.includes(`class ${className}`)) {
      // Try to fix common class name mismatches
      const classMatch = cleaned.match(/public\s+class\s+(\w+)/);
      if (classMatch && classMatch[1] !== className) {
        cleaned = cleaned.replace(new RegExp(`class\\s+${classMatch[1]}`, 'g'), `class ${className}`);
      }
    }
    
    return cleaned;
  }
  
  /**
   * Compiles the plugin with Maven
   */
  private async compileMaven(projectDir: string, pluginName: string, onProgress?: (progress: number) => void): Promise<string> {
    try {
      // Run Maven clean package with progress tracking
      onProgress?.(0);
      
      console.log('[BUILD] Starting Maven compilation for:', pluginName);
      console.log('[BUILD] Project directory:', projectDir);
      
      const { stdout, stderr } = await execAsync('mvn clean package -DskipTests -e', {
        cwd: projectDir,
        timeout: 120000, // 2 minutes timeout
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer for output
      });
      
      onProgress?.(100);
      
      console.log('[BUILD] Maven build output:', stdout);
      if (stderr) console.log('[BUILD] Maven build stderr:', stderr);
      
      // Check for build success
      if (!stdout.includes('BUILD SUCCESS')) {
        console.error('[BUILD] Maven build did not complete successfully');
        console.error('[BUILD] Full output:', stdout);
        
        // Create error with detailed output
        const error: any = new Error('Maven build failed - check compilation errors in the generated code');
        error.stdout = stdout;
        error.stderr = stderr;
        throw error;
      }
      
      // Find the JAR file
      const targetDir = path.join(projectDir, 'target');
      const files = await fs.readdir(targetDir);
      const jarFile = files.find(f => f.endsWith('.jar') && !f.includes('original'));
      
      if (!jarFile) {
        console.error('[BUILD] Available files in target:', files);
        throw new Error('JAR file not found after build');
      }
      
      console.log('[BUILD] Successfully created JAR:', jarFile);
      return path.join(targetDir, jarFile);
    } catch (error) {
      console.error('[BUILD] Maven build failed:', error);
      
      if (error instanceof Error) {
        // Preserve stdout/stderr if they exist
        const errorWithOutput: any = error;
        
        // Extract meaningful error from Maven output
        const errorMessage = error.message;
        if (errorMessage.includes('compilation failure') || errorMessage.includes('COMPILATION ERROR')) {
          const newError: any = new Error('Java compilation failed - please check your code for syntax errors');
          newError.stdout = errorWithOutput.stdout;
          newError.stderr = errorWithOutput.stderr;
          throw newError;
        } else if (errorMessage.includes('timeout')) {
          throw new Error('Build timeout - the compilation took too long');
        } else if (errorMessage.includes('Cannot run program "mvn"')) {
          throw new Error('Maven is not installed or not in PATH');
        }
      }
      
      throw error;
    }
  }
  
  /**
   * Generates all plugin files without building
   */
  async generateAllFiles(config: PluginBuildConfig): Promise<Array<{ name: string; content: string; type: string }>> {
    const files: Array<{ name: string; content: string; type: string }> = [];
    
    // Generate pom.xml
    const pomXml = await this.generatePomXmlContent(config);
    files.push({ name: 'pom.xml', content: pomXml, type: 'xml' });
    
    // Generate plugin.yml
    const pluginYml = await this.generatePluginYmlContent(config);
    files.push({ name: 'plugin.yml', content: pluginYml, type: 'yaml' });
    
    // Generate config.yml
    const configYml = `# Configuration file for ${config.pluginName}\n# Add your plugin configuration here\n`;
    files.push({ name: 'config.yml', content: configYml, type: 'yaml' });
    
    // Add Java code with enhancements
    const enhancedJavaCode = await this.enhanceJavaCode(config);
    const className = config.mainClass.split('.').pop() || 'Main';
    files.push({ name: `${className}.java`, content: enhancedJavaCode, type: 'java' });
    
    // Generate README
    const readme = this.generateReadme(config);
    files.push({ name: 'README.md', content: readme, type: 'markdown' });
    
    return files;
  }
  
  /**
   * Generates pom.xml content
   */
  private async generatePomXmlContent(config: PluginBuildConfig): Promise<string> {
    const apiVersion = this.getApiVersion(config.minecraftVersion);
    const repository = this.getRepository(config.apiType);
    const dependency = this.getDependency(config.apiType, apiVersion);
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.coderslab</groupId>
    <artifactId>${config.pluginName.toLowerCase()}</artifactId>
    <version>${config.version}</version>
    <packaging>jar</packaging>

    <name>${config.pluginName}</name>
    <description>Generated by CodersLab</description>

    <properties>
        <java.version>17</java.version>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>\${java.version}</source>
                    <target>\${java.version}</target>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-shade-plugin</artifactId>
                <version>3.5.0</version>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>shade</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>

    <repositories>
        ${repository}
    </repositories>

    <dependencies>
        ${dependency}
    </dependencies>
</project>`;
  }
  
  /**
   * Generates plugin.yml content
   */
  private async generatePluginYmlContent(config: PluginBuildConfig): Promise<string> {
    const apiVersion = this.getApiVersion(config.minecraftVersion);
    
    return `name: ${config.pluginName}
version: ${config.version}
main: ${config.mainClass}
api-version: '${apiVersion}'
description: Built by Seazon - Join our Discord at https://discord.gg/rx3H3m39AX
author: Seazon
website: https://discord.gg/rx3H3m39AX
`;
  }
  
  /**
   * Enhances Java code with missing imports and package
   */
  private async enhanceJavaCode(config: PluginBuildConfig): Promise<string> {
    const packageName = config.mainClass.split('.').slice(0, -1).join('.');
    const className = config.mainClass.split('.').pop()!;
    return this.cleanJavaCode(config.javaCode.trim(), packageName, className);
  }
  
  /**
   * Generates README.md
   */
  private generateReadme(config: PluginBuildConfig): string {
    return `# ${config.pluginName}

**Version:** ${config.version}  
**Minecraft Version:** ${config.minecraftVersion}  
**API:** ${config.apiType}  
**Built by:** Seazon

## Support & Community

Join our Discord server for support, updates, and community:  
ðŸ”— **https://discord.gg/rx3H3m39AX**

## Installation

1. Download the plugin JAR file
2. Place it in your server's \`plugins/\` folder
3. Restart or reload your server
4. Configure the plugin in \`plugins/${config.pluginName}/config.yml\`

## Building from Source

### Prerequisites
- Java 17 or higher
- Maven 3.6 or higher

### Build Steps
\`\`\`bash
mvn clean package
\`\`\`

The compiled JAR will be in the \`target/\` directory.

## Configuration

Edit \`config.yml\` to customize the plugin settings.

## Support

For issues, questions, or suggestions:
- Join our Discord: https://discord.gg/rx3H3m39AX
- Report bugs in our Discord server

---

**Built by Seazon | Join our community on Discord ðŸŽ®**
`;
  }

  /**
   * Cleanup build directory
   */
  private async cleanup(projectDir: string): Promise<void> {
    try {
      await fs.rm(projectDir, { recursive: true, force: true });
    } catch (error) {
      console.error('Cleanup failed:', error);
    }
  }
  
  /**
   * Get API version from Minecraft version
   */
  private getApiVersion(minecraftVersion: string): string {
    const versionMap: Record<string, string> = {
      '1.19': '1.19',
      '1.19.1': '1.19',
      '1.19.2': '1.19',
      '1.19.3': '1.19',
      '1.19.4': '1.19',
      '1.20': '1.20',
      '1.20.1': '1.20',
      '1.20.2': '1.20',
      '1.20.3': '1.20',
      '1.20.4': '1.20',
      '1.20.5': '1.20',
      '1.20.6': '1.20',
      '1.21': '1.21',
      '1.21.1': '1.21',
      '1.21.2': '1.21',
      '1.21.3': '1.21',
      '1.21.4': '1.21'
    };
    
    return versionMap[minecraftVersion] || '1.20';
  }
  
  /**
   * Get Maven repository configuration
   */
  private getRepository(apiType: string): string {
    const repositories: Record<string, string> = {
      spigot: `<repository>
            <id>spigot-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>`,
      paper: `<repository>
            <id>papermc</id>
            <url>https://repo.papermc.io/repository/maven-public/</url>
        </repository>`,
      bukkit: `<repository>
            <id>spigot-repo</id>
            <url>https://hub.spigotmc.org/nexus/content/repositories/snapshots/</url>
        </repository>`
    };
    
    return repositories[apiType] || repositories.spigot;
  }
  
  /**
   * Get Maven dependency configuration
   */
  private getDependency(apiType: string, apiVersion: string): string {
    const dependencies: Record<string, string> = {
      spigot: `<dependency>
            <groupId>org.spigotmc</groupId>
            <artifactId>spigot-api</artifactId>
            <version>${apiVersion}-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>`,
      paper: `<dependency>
            <groupId>io.papermc.paper</groupId>
            <artifactId>paper-api</artifactId>
            <version>${apiVersion}-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>`,
      bukkit: `<dependency>
            <groupId>org.bukkit</groupId>
            <artifactId>bukkit</artifactId>
            <version>${apiVersion}-R0.1-SNAPSHOT</version>
            <scope>provided</scope>
        </dependency>`
    };
    
    return dependencies[apiType] || dependencies.spigot;
  }
  
  /**
   * Check if Maven is installed
   */
  static async isMavenInstalled(): Promise<boolean> {
    try {
      await execAsync('mvn --version');
      return true;
    } catch {
      return false;
    }
  }
}
